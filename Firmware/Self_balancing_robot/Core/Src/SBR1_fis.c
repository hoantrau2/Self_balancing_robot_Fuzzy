/* Fuzzy inference system generated by qfiscgen.m for the qFIS engine*/
/* Generated : 24-Nov-2023 13:17:44 */
/* MATLAB Version: 9.6.0.1072779 (R2019a) */
/* Note: Based on the qFIS engine from https://github.com/kmilo17pet/qlibs */

#include "SBR1_fis.h"
#include "qfis.h"

/* FIS Object */
static qFIS_t SBR1;
/* I/O Fuzzy Objects */
static qFIS_Input_t SBR1_inputs[ 2 ];
static qFIS_Output_t SBR1_outputs[ 1 ];
/* I/O Membership Objects */
static qFIS_MF_t MFin[ 10 ], MFout[ 7 ];
/* I/O Names */
enum { theta, thetadot };
enum { u };
/* I/O Membership functions tags */
enum { theta_NB, theta_NS, theta_ZE, theta_PS, theta_PB, thetadot_NB, thetadot_NS, thetadot_ZE, thetadot_PS, thetadot_PB };
enum { u_NB, u_NM, u_NS, u_ZE, u_PS, u_PM, u_PB };
/* Rules of the inference system */
static const qFIS_Rules_t rules[] = {
    QFIS_RULES_BEGIN
       IF theta IS theta_NB AND thetadot IS thetadot_NB THEN u IS u_NB END
       IF theta IS theta_NB AND thetadot IS thetadot_NS THEN u IS u_NB END
       IF theta IS theta_NB AND thetadot IS thetadot_ZE THEN u IS u_NM END
       IF theta IS theta_NB AND thetadot IS thetadot_PS THEN u IS u_NS END
       IF theta IS theta_NB AND thetadot IS thetadot_PB THEN u IS u_ZE END
       IF theta IS theta_NS AND thetadot IS thetadot_NB THEN u IS u_NB END
       IF theta IS theta_NS AND thetadot IS thetadot_NS THEN u IS u_NM END
       IF theta IS theta_NS AND thetadot IS thetadot_ZE THEN u IS u_NS END
       IF theta IS theta_NS AND thetadot IS thetadot_PS THEN u IS u_ZE END
       IF theta IS theta_NS AND thetadot IS thetadot_PB THEN u IS u_PS END
       IF theta IS theta_ZE AND thetadot IS thetadot_NB THEN u IS u_NM END
       IF theta IS theta_ZE AND thetadot IS thetadot_NS THEN u IS u_NS END
       IF theta IS theta_ZE AND thetadot IS thetadot_ZE THEN u IS u_ZE END
       IF theta IS theta_ZE AND thetadot IS thetadot_PS THEN u IS u_PS END
       IF theta IS theta_ZE AND thetadot IS thetadot_PB THEN u IS u_PM END
       IF theta IS theta_PS AND thetadot IS thetadot_NB THEN u IS u_NS END
       IF theta IS theta_PS AND thetadot IS thetadot_NS THEN u IS u_ZE END
       IF theta IS theta_PS AND thetadot IS thetadot_ZE THEN u IS u_PS END
       IF theta IS theta_PS AND thetadot IS thetadot_PS THEN u IS u_PM END
       IF theta IS theta_PS AND thetadot IS thetadot_PB THEN u IS u_PB END
       IF theta IS theta_PB AND thetadot IS thetadot_NB THEN u IS u_ZE END
       IF theta IS theta_PB AND thetadot IS thetadot_NS THEN u IS u_PS END
       IF theta IS theta_PB AND thetadot IS thetadot_ZE THEN u IS u_PM END
       IF theta IS theta_PB AND thetadot IS thetadot_PS THEN u IS u_PB END
       IF theta IS theta_PB AND thetadot IS thetadot_PB THEN u IS u_PB END
    QFIS_RULES_END
};
/* Rule strengths */
float rStrength[ 25 ] = { 0.0f };

/* Parameters of the membership functions */
//static const float theta_NB_p[] = { -2.0000f, -1.50000f, -0.6000f, -0.4000f };
//static const float theta_NS_p[] = { -0.6000f, -0.4000f, -0.2500f, 0.0000f };
//static const float theta_ZE_p[] = { -0.2500f, 0.0000f, 0.25000f };
//static const float theta_PS_p[] = { 0.0000f, 0.25000f, 0.4000f, 0.600f };
//static const float theta_PB_p[] = { 0.4000f, 0.600f, 1.50000f, 2.0000f };
//static const float thetadot_NB_p[] = { -5.0000f, -1.0000f, -0.600f };
//static const float thetadot_NS_p[] = { -1.0000f, -0.600f, 0.0000f };
//static const float thetadot_ZE_p[] = { -0.600f, 0.0000f, 0.600f };
//static const float thetadot_PS_p[] = { 0.0000f, 0.600f, 1.0000f };
//static const float thetadot_PB_p[] = { 0.600f, 1.0000f, 5.0000f };
////static const float theta_NB_p[] = { -10.0000f, -9.0000f, -0.3000f, -0.22000f };
////static const float theta_NS_p[] = { -0.3000f, -0.22000f, -0.1800f, 0.0000f };
////static const float theta_ZE_p[] = { -0.1800f, 0.0000f, 0.13000f };
////static const float theta_PS_p[] = { 0.0000f, 0.13000f, 0.2000f, 0.2600f };
////static const float theta_PB_p[] = { 0.2000f, 0.2600f, 9.0000f, 10.0000f };
////static const float thetadot_NB_p[] = { -5.0000f, -1.0000f, -0.5500f };
////static const float thetadot_NS_p[] = { -1.0000f, -0.5500f, 0.0000f };
////static const float thetadot_ZE_p[] = { -0.5500f, 0.0000f, 0.5500f };
////static const float thetadot_PS_p[] = { 0.0000f, 0.5500f, 1.0000f };
////static const float thetadot_PB_p[] = { 0.5500f, 1.0000f, 5.0000f };
//static const float u_NB_p[] = { -0.419f };
//static const float u_NM_p[] = { -0.300f };//-0.6670
//static const float u_NS_p[] = { -0.1500f };
//static const float u_ZE_p[] = { 0.0000f };
//static const float u_PS_p[] = { 0.1500f };
//static const float u_PM_p[] = { 0.300f };//0.6670
//static const float u_PB_p[] = { 0.41900f };

static const float theta_NB_p[] = { -2.0000f, -1.50000f, -0.3000f, -0.22000f };
static const float theta_NS_p[] = { -0.3000f, -0.22000f, -0.1800f, 0.0000f };
static const float theta_ZE_p[] = { -0.1800f, 0.0000f, 0.13000f };
static const float theta_PS_p[] = { 0.0000f, 0.13000f, 0.2000f, 0.2600f };
static const float theta_PB_p[] = { 0.2000f, 0.2600f, 1.50000f, 2.0000f };
static const float thetadot_NB_p[] = { -1.50000f, -1.0000f, -0.5400f };
static const float thetadot_NS_p[] = { -1.0000f, -0.5400f, 0.0000f };
static const float thetadot_ZE_p[] = { -0.5400f, 0.0000f, 0.5400f };
static const float thetadot_PS_p[] = { 0.0000f, 0.5400f, 1.0000f };
static const float thetadot_PB_p[] = { 0.5400f, 1.0000f, 1.50000f };
static const float u_NB_p[] = { -0.519f };
static const float u_NM_p[] = { -0.3500f };//-0.6670
static const float u_NS_p[] = { -0.2500f };
static const float u_ZE_p[] = { 0.0000f };
static const float u_PS_p[] = { 0.2500f };
static const float u_PM_p[] = { 0.3500f };//0.6670
static const float u_PB_p[] = { 0.51900f };


void SBR1_init( void ){
    /* Set inputs */
    qFIS_InputSetup( SBR1_inputs, theta, -1.0000f, 1.0000f );
    qFIS_InputSetup( SBR1_inputs, thetadot, -1.0000f, 1.0000f );
    /* Set outputs */
    qFIS_OutputSetup( SBR1_outputs, u, -1.0000f, 1.0000f );
    /* Set membership functions for the inputs */
    qFIS_SetMF( MFin, theta, theta_NB, trapmf, NULL, theta_NB_p, 1.0f );
    qFIS_SetMF( MFin, theta, theta_NS, trapmf, NULL, theta_NS_p, 1.0f );
    qFIS_SetMF( MFin, theta, theta_ZE, trimf, NULL, theta_ZE_p, 1.0f );
    qFIS_SetMF( MFin, theta, theta_PS, trapmf, NULL, theta_PS_p, 1.0f );
    qFIS_SetMF( MFin, theta, theta_PB, trapmf, NULL, theta_PB_p, 1.0f );
    qFIS_SetMF( MFin, thetadot, thetadot_NB, trimf, NULL, thetadot_NB_p, 1.0f );
    qFIS_SetMF( MFin, thetadot, thetadot_NS, trimf, NULL, thetadot_NS_p, 1.0f );
    qFIS_SetMF( MFin, thetadot, thetadot_ZE, trimf, NULL, thetadot_ZE_p, 1.0f );
    qFIS_SetMF( MFin, thetadot, thetadot_PS, trimf, NULL, thetadot_PS_p, 1.0f );
    qFIS_SetMF( MFin, thetadot, thetadot_PB, trimf, NULL, thetadot_PB_p, 1.0f );
    /* Set membership functions for the outputs */
    qFIS_SetMF( MFout, u, u_NB, constantmf, NULL, u_NB_p, 1.0f );
    qFIS_SetMF( MFout, u, u_NM, constantmf, NULL, u_NM_p, 1.0f );
    qFIS_SetMF( MFout, u, u_NS, constantmf, NULL, u_NS_p, 1.0f );
    qFIS_SetMF( MFout, u, u_ZE, constantmf, NULL, u_ZE_p, 1.0f );
    qFIS_SetMF( MFout, u, u_PS, constantmf, NULL, u_PS_p, 1.0f );
    qFIS_SetMF( MFout, u, u_PM, constantmf, NULL, u_PM_p, 1.0f );
    qFIS_SetMF( MFout, u, u_PB, constantmf, NULL, u_PB_p, 1.0f );

    /* Configure the Inference System */
    qFIS_Setup( &SBR1, Sugeno,
                SBR1_inputs, sizeof(SBR1_inputs),
                SBR1_outputs, sizeof(SBR1_outputs),
                MFin, sizeof(MFin), MFout, sizeof(MFout),
                rules, rStrength, 25u );
    qFIS_SetParameter( &SBR1, qFIS_AND, qFIS_PROD );
    qFIS_SetParameter( &SBR1, qFIS_Implication, qFIS_PROD );
    qFIS_SetParameter( &SBR1, qFIS_Aggregation, qFIS_SUM );
}

void SBR1_run( float *inputs, float *outputs ) {
    /* Set the crips inputs */
    qFIS_SetInput( SBR1_inputs, theta, inputs[ theta ] );
    qFIS_SetInput( SBR1_inputs, thetadot, inputs[ thetadot ] );

    qFIS_Fuzzify( &SBR1 );
    if ( qFIS_Inference( &SBR1 ) > 0 ) {
        qFIS_DeFuzzify( &SBR1 );
    }
    else {
        /* Error! */
    }

    /* Get the crips outputs */
    outputs[ u ] = qFIS_GetOutput( SBR1_outputs, u );
}
